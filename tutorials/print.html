<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Machinery Tutorial Book</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li class="chapter-item expanded "><a href="creation_graph/index.html"><strong aria-hidden="true">2.</strong> Creation Graph</a></li><li class="chapter-item expanded "><a href="the_truth/index.html"><strong aria-hidden="true">3.</strong> The Truth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="the_truth/custom_asset/index.html"><strong aria-hidden="true">3.1.</strong> Creating a custom asset</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="the_truth/custom_asset/part1.html"><strong aria-hidden="true">3.1.1.</strong> Part 1</a></li><li class="chapter-item expanded "><a href="the_truth/custom_asset/part2.html"><strong aria-hidden="true">3.1.2.</strong> Part 2</a></li><li class="chapter-item expanded "><a href="the_truth/custom_asset/part3.html"><strong aria-hidden="true">3.1.3.</strong> Part 3</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ui/index.html"><strong aria-hidden="true">4.</strong> UI</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Machinery Tutorial Book</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/OurMachinery/themachinery-books" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Hi,</p>
<p>This book is here to give you guidance on how to work with the engine. We are constantly working on
improving the onboarding as much as possible.</p>
<p>Enjoy!</p>
<p><em>The Machinery Team</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creation-graph"><a class="header" href="#creation-graph">Creation Graph</a></h1>
<p>In The Machinery, we provide full control over how data enters the engine and what data-processing
steps that get executed, allowing technical artists to better optimize content and setup custom,
game-specific asset pipelines. </p>
<p>This is handled through <em>Creation Graphs</em>. A <em>Creation Graph</em> is essentially a generic framework for
processing arbitrary data on the CPUs and GPUs, exposed through a graph front-end view. While we can
use <em>Creation Graphs</em> for any type of data processing.</p>
<p>The following section will guide you from basic use cases to more advanced use cases.</p>
<p>We have a couple of blog posts which might also be a valid source of information and interesting to
you.</p>
<ul>
<li><a href="https://ourmachinery.com/post/creation-graphs/">Creation Graphs</a></li>
<li><a href="https://ourmachinery.com/post/more-on-creation-graphs/">More on Creation Graphs</a></li>
<li><a href="https://ourmachinery.com/post/summer-fun-with-creation-graphs/">Summer Fun with Creation Graphs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-truth"><a class="header" href="#the-truth">The Truth</a></h1>
<p>The Machinery uses a powerful data model to represent edited assets. This model has built-in support
for serialization, streaming, copy/paste, drag-and-drop as well as unlimited undo/redo. It supports
an advanced hierarchical prefab model for making derivative object instances and propagating
changes. It even has full support for real-time collaboration. Multiple people can work together in
the same game project, Google Docs-style. Since all of these features are built into the data model
itself, your custom, game-specific data will get them automatically, without you having to write a
line of code.</p>
<p>This section shall introduce you to some more complex topics such as <a href="the_truth//the_truth/custom_asset/index.html"><em>How to create your own asset.</em></a></p>
<p>For more information checkout the <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html">documentation</a> and these blog posts: <a href="https://ourmachinery.com/post/the-story-behind-the-truth-designing-a-data-model/">The Story behind The Truth: Designing a Data Model</a>  or this <a href="https://ourmachinery.com/post/multi-threading-the-truth/">one</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-custom-asset"><a class="header" href="#creating-a-custom-asset">Creating a custom asset</a></h1>
<p>This walkthrough series shows you how to add a custom asset to the Engine. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="the_truth/custom_asset/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. The goal for this walkthrough is to write a text file asset.</p>
<p>In the parts 1 - 3 we will cover the following topics:</p>
<ul>
<li><a href="the_truth/custom_asset//tutorials/the_truth/custom_asset/part1.html#creating-an-asset-the-truth-type">How to create your asset</a></li>
<li><a href="the_truth/custom_asset//tutorials/the_truth/custom_asset/part1.html#what-is-the-difference-between-truth-type-and-asset">What is the difference between a Truth Type and an Asset?</a></li>
<li><a href="the_truth/custom_asset//tutorials/the_truth/custom_asset/part1.html#appendix-adding-an-asset-via-code-to-the-asset-browser">Add a asset via code to the project</a></li>
<li><a href="the_truth/custom_asset//tutorials/the_truth/custom_asset/part2.html#text-file-asset">How to associate data with your asset</a></li>
<li><a href="the_truth/custom_asset//tutorials/the_truth/custom_asset/part2.html#custom-ui">How to add a custom UI to your asset</a></li>
<li><a href="the_truth/custom_asset//tutorials/the_truth/custom_asset/part3.html#custom-importer-for-text-files">How to create your importer</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-custom-asset-part-1"><a class="header" href="#create-a-custom-asset-part-1">Create a custom asset part 1</a></h1>
<p>This walkthrough shows you how to add a custom asset to the Engine. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="the_truth/custom_asset//the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. The goal for this walkthrough is to write a text file asset.</p>
<p>In the parts 1 - 3 we will cover the following topics:</p>
<ul>
<li>How to create your asset</li>
<li>How to associate data with your asset</li>
<li>How to add a custom UI to your asset</li>
<li>How to create your importer</li>
</ul>
<p>This part will cover the following topics:</p>
<ul>
<li>What to think of in advance?</li>
<li>Creating an essential asset The Truth type</li>
<li>Being able to add the asset to the asset browser
<ul>
<li>Via context Menu</li>
<li>Via code</li>
</ul>
</li>
</ul>
<p>The next part will explore how to store more complex data in an asset file and how to get this data back into the Engine.</p>
<blockquote>
<p>You can find the whole source code in its git repo: <a href="https://github.com/simon-ourmachinery/example-text-file-asset">example-text-file-asset</a></p>
</blockquote>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_truth/custom_asset/part1.html#first-step-what-kind-of-asset-do-we-want-to-create">First step: What kind of asset do we want to create?</a></li>
<li><a href="the_truth/custom_asset/part1.html#creating-an-asset-the-truth-type">Creating an asset The Truth Type</a>
<ul>
<li><a href="the_truth/custom_asset/part1.html#what-is-the-difference-between-truth-type-and-asset">What is the difference between Truth Type and Asset?</a></li>
</ul>
</li>
<li><a href="the_truth/custom_asset/part1.html#making-the-asset-browser-able-to-create-it">Making the Asset Browser able to create it</a></li>
<li><a href="the_truth/custom_asset/part1.html#what-is-next">What is next?</a></li>
<li><a href="the_truth/custom_asset/part1.html#appendix-adding-an-asset-via-code-to-the-asset-browser">Appendix: Adding an asset via code to the Asset Browser</a></li>
<li><a href="the_truth/custom_asset/part1.html#full-example-of-basic-asset">Full example of basic asset</a></li>
</ul>
<h2 id="first-step-what-kind-of-asset-do-we-want-to-create"><a class="header" href="#first-step-what-kind-of-asset-do-we-want-to-create"><strong>First step:</strong> What kind of asset do we want to create?</a></h2>
<p>Sometimes it is needed to add a custom asset to the Engine to support different asset types which are not supported yet. The first step is that we need to decide what our asset shall represent. In this case, it will be a text file. Those decisions have some influence on the details of the implementation. How ever the steps discussed below are the same in any case.</p>
<h2 id="creating-an-asset-the-truth-type"><a class="header" href="#creating-an-asset-the-truth-type">Creating an asset The Truth Type</a></h2>
<p>The Engine needs to know that there shall be a new asset type. That is why we need to register a new Truth type. Those steps are the same for every truth type, be it an asset or not.</p>
<p>We need to define a globally accessible definition for the name of the type and its hash value. The usual place for this is a header file.</p>
<p>Example Header file: <code>my_asset.h</code></p>
<pre><code class="language-c">#pragma once
#include &quot;entity_api_types.h&quot;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0xc0995d6c144ac64aULL)
</code></pre>
<p>(Do not forget to run hash.exe when you create a <code>TM_STATIC_HASH</code>, mode information here.)</p>
<p>Now we need to define the layout of our asset type. We should always do this during plugin load. (<code>tm_load_plugin</code>) 
During this call we need to register a function to the <code>TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME</code> interface. 
This function is typically called <code>create_truth_types</code>, but its name can be arbitrary.</p>
<blockquote>
<p><strong>Note:</strong> An interface is an abstract structure that maps a struct (the interface) to a hash value/name. It allows for customization points. In The Machinery, the Engine uses this extensively.</p>
</blockquote>
<p>Example <code>tm_load_plugin</code> function for <code>my_asset.c</code></p>
<pre><code class="language-c">TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
}
</code></pre>
<p>After we did this, let us implement the actual function. First, we need to create a Truth type:
We use the function <code>tm_the_truth_api-&gt;create_object_type(tm_the_truth_o *tt, const char *name, const tm_the_truth_property_definition_t *properties, uint32_t num_properties);</code> . This one will register in the Truth a new type with the name and the properties we give the type. </p>
<p>At this point, we have a normal The Truth type. But we wanted to create an asset! </p>
<h4 id="what-is-the-difference-between-truth-type-and-asset"><a class="header" href="#what-is-the-difference-between-truth-type-and-asset">What is the difference between Truth Type and Asset?</a></h4>
<p>An asset is just a normal truth type. The structure of an asset in the truth is defined in the <code>foundation/the_truth_assets.h</code>. An asset itself is, therefore, nothing else than a wrapper around our actual asset. It provides a generic interface to provide some standard information.</p>
<p>The structure of an asset type looks like this:</p>
<pre><code class="language-c">enum {
    // Name of the asset.
    TM_TT_PROP__ASSET__NAME, // string
    // Directory where the asset resides. For top-level assets, this is `NULL`.
    TM_TT_PROP__ASSET__DIRECTORY, // reference [[TM_TT_TYPE__ASSET_DIRECTORY]]
    // Labels applied to this asset.
    TM_TT_PROP__ASSET__UUID_LABELS, // subobject_set(UINT64_T) storing the UUID of the associated label.
    // Subobject with the actual data of the asset. The type of this subobject depends on the type
    // of data storedin this asset.
    TM_TT_PROP__ASSET__OBJECT, // subobject(*)
    // Thumbnail image associated with asset
    TM_TT_PROP__ASSET__THUMBNAIL, // buffer
};
</code></pre>
<p>The truth type of the text file we just created will live as a subobject of the Asset Truth Type in the property field: <code>TM_TT_PROP__ASSET__OBJECT</code>.</p>
<p>Let us move on and go back and finish the definition of our type. Let us add a file extension to our type. All we need to do is add an aspect of type <code>TM_TT_ASPECT__FILE_EXTENSION</code> to our Truth Type. You can find it in the following header file <code>foundation/the_truth_assets.h</code>.</p>
<blockquote>
<p><strong>Note:</strong> The Machinery will automatically prefix your file extension with <strong>tm_</strong></p>
</blockquote>
<p>In code, this looks as follows:</p>
<pre><code class="language-c">static void create_truth_types(struct tm_the_truth_o *tt)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, 0, 0);
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;my_asset&quot;);
}
</code></pre>
<p>We create a type of name <code>TM_TT_TYPE__MY_ASSET</code> with no properties and a file extension my_asset (<code>.tm_my_asset</code> in your explorer). </p>
<h2 id="making-the-asset-browser-able-to-create-it"><a class="header" href="#making-the-asset-browser-able-to-create-it">Making the Asset Browser able to create it</a></h2>
<p>Now that there is a basic asset type, you might want the asset browser to create it via the <code>New Asset</code> context menu. All you need to do is register the asset to the <code>TM_ASSET_BROWSER_CREATE_ASSET_INTERFACE_NAME</code> interface. This interface requires an implementation of the type <code>tm_asset_browser_create_asset_i</code>:</p>
<pre><code class="language-c">typedef struct tm_asset_browser_create_asset_i
{
    struct tm_asset_browser_create_asset_o *inst;
    // TM_LOCALIZE_LATER() name of menu option to display for creating the asset (e.g. &quot;New
    // Entity&quot;).
    const char *menu_name;
    // TM_LOCALIZE_LATER() name of the newly created asset (e.g. &quot;New Entity&quot;);
    const char *asset_name;
    // Create callback, should return The Truth ID for the newly created asset.
    tm_tt_id_t (*create)(struct tm_asset_browser_create_asset_o *inst, struct tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope);
} tm_asset_browser_create_asset_i;
</code></pre>
<p>Source: <code>plugins/editor_views/asset_browser.h</code></p>
<p>For our basic type, this interface can be defined as follows:</p>
<pre><code class="language-c">static tm_tt_id_t asset_browser_create(struct tm_asset_browser_create_asset_o *inst, tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE__MY_ASSET);
    return tm_the_truth_api-&gt;create_object_of_type(tt, type, undo_scope);
}

static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New My Asset&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New My Asset&quot;),
    .create = asset_browser_create,
};
</code></pre>
<p>What is happening?</p>
<ul>
<li>In this case, the function <code>asset_browser_create</code> creates the object of our type. Here we could do more complex things if the asset were more complicated. </li>
<li>The <em>menu name</em> is for the context menu, while the <em>asset name</em> functions as the default asset name. </li>
</ul>
<p>Now we register our code to the interface. We do this also in the load plugin function.</p>
<p>Example <code>tm_load_plugin</code> function for <code>my_asset.c</code></p>
<pre><code class="language-c">TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
   tm_add_or_remove_implementation(reg, load, TM_ASSET_BROWSER_CREATE_ASSET_INTERFACE_NAME, &amp;asset_browser_create_my_asset);
}
</code></pre>
<p>When we open the Engine, we can open the Asset Browser and create our asset:</p>
<p><img src="https://paper-attachments.dropbox.com/s_080D43F0A98EB2BE6BBB6D719C7B3B910F38D78674006103833AED0070469AD4_1609883533160_image.png" alt="" /></p>
<p>What happens is not existing! But we are getting there! Check out the <a href="the_truth/custom_asset/part1.html#">next part</a> for more complex and existing actions.</p>
<h2 id="what-is-next"><a class="header" href="#what-is-next">What is next?</a></h2>
<p>The next part will refactor the current code and show you how to make your code and asset more useful by implementing the action asset.</p>
<p><a href="the_truth/custom_asset//tutorials/the_truth/custom_asset/part3.html">Part 2</a></p>
<h2 id="appendix-adding-an-asset-via-code-to-the-asset-browser"><a class="header" href="#appendix-adding-an-asset-via-code-to-the-asset-browser">Appendix: Adding an asset via code to the Asset Browser</a></h2>
<p>Sometimes it is necessary to create an asset via code. The Asset Browser plugin provides a solution for this the <code>tm_asset_browser_add_asset_api</code>. With this API assets can be created and added to the current project.</p>
<p>To add an asset to the asset browser a few steps are needed. </p>
<ol>
<li>First, we need to pick the correct type. We need to request it from the truth via the type hash (in this example, <code>TM_TT_TYPE_HASH__MY_ASSET</code>). </li>
<li>Secondly, we should create an object of the correct type. </li>
<li>Then we can request the asset browser API if the API not globally accessible.</li>
</ol>
<blockquote>
<p>If we already requested the API, we do not need to do this step and can use the already defined instance of the API.</p>
</blockquote>
<ol start="4">
<li>We need to create a undo scope. (We could also use <code>TM_TT_NO_UNDO_SCOPE</code>) but its not recommended!</li>
<li>Then, we should decide if we should highlight the new asset in the Asset Browser. (<code>should_select=true</code>) If that's needed, an instance of the current UI is required. </li>
<li>Then, the magic can happen and we can call the function <code>add</code> of the <code>tm_asset_browser_add_asset_api</code> </li>
</ol>
<p>The following code example will demonstrate how to add my_asset via code to the current project.</p>
<pre><code class="language-c">// ... other includes
#include &lt;foundation/the_truth.h&gt;
#include &lt;foundation/undo.h&gt;

#include &lt;plugins/editor_views/asset_browser.h&gt;

#include &quot;my_asset.h&quot;
//... other code

static void add_my_asset_to_project(tm_the_truth_o *tt,struct tm_ui_o *ui,const char*asset_name, tm_tt_id_t target_dir){
    const tm_tt_type_t my_asset_type_id= tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
    const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, my_asset_type_id, TM_TT_NO_UNDO_SCOPE);
tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
const tm_tt_undo_scope_t undo_scope = tm_the_truth_api-&gt;create_undo_scope(tt, TM_LOCALIZE(&quot;Add My Asset to Project&quot;));
bool should_select = true;
// we do not have any asset label therefore we do not need to pass them thats why the last
// 2 arguments are 0 and 0!
add_asset-&gt;add(add_asset-&gt;inst, target_dir, asset_id, asset_name, undo_scope,should_select,ui,0,0);
}
</code></pre>
<h2 id="full-example-of-basic-asset"><a class="header" href="#full-example-of-basic-asset">Full example of basic asset</a></h2>
<p><code>my_asset.h</code></p>
<pre><code class="language-c">#pragma once
#include &lt;foundation/api_types.h&gt;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0x1e12ba1f91b99960ULL)
</code></pre>
<p>(Do not forget to run hash.exe when you create a <code>TM_STATIC_HASH</code>)</p>
<p><code>my_asset.c</code></p>
<pre><code class="language-c">// -- api's
static struct tm_the_truth_api *tm_the_truth_api;
// -- inlcudes
#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/the_truth.h&gt;
#include &lt;foundation/undo.h&gt;
#include &lt;foundation/the_truth_assets.h&gt;
#include &lt;foundation/localizer.h&gt;

#include &lt;plugins/editor_views/asset_browser.h&gt;

#include &quot;my_asset.h&quot;

// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    // we have properties this is why the last arguments are &quot;0, 0&quot;
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, 0, 0);
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;my_asset&quot;);
}

// -- asset browser regsiter interface
static tm_tt_id_t asset_browser_create(struct tm_asset_browser_create_asset_o *inst, tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
    return tm_the_truth_api-&gt;create_object_of_type(tt, type, undo_scope);
}
static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New My Asset&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New My Asset&quot;),
    .create = asset_browser_create,
};

// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_the_truth_api = reg-&gt;get(TM_THE_TRUTH_API_NAME);
    tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
    tm_add_or_remove_implementation(reg, load, TM_ASSET_BROWSER_CREATE_ASSET_INTERFACE_NAME, &amp;asset_browser_create_my_asset);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-custom-asset-part-2"><a class="header" href="#create-a-custom-asset-part-2">Create a custom asset part 2</a></h1>
<p>This walkthrough shows you how to add a custom asset to the Engine. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="the_truth/custom_asset//the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. The goal for this walkthrough is to write a text file asset.</p>
<p>This part will cover the following topics:</p>
<ul>
<li>How to store data in a buffer that is associated with the asset file</li>
<li>How to add a custom UI to be associated with the asset.</li>
</ul>
<p>When you have finished this part in the <a href="the_truth/custom_asset//tutorials/the_truth/custom_asset/part3.html">next one</a>, we will show you how to write your importer.</p>
<blockquote>
<p>You can find the whole source code in its git repo: <a href="https://github.com/simon-ourmachinery/example-text-file-asset">example-text-file-asset</a></p>
</blockquote>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_truth/custom_asset/part2.html#extending-the-asset-the-truth-type">Extending the asset The Truth Type</a></li>
<li><a href="the_truth/custom_asset/part2.html#text-file-asset">Text file asset</a></li>
<li><a href="the_truth/custom_asset/part2.html#load-a-text-file">Load a text file</a>
<ul>
<li><a href="the_truth/custom_asset/part2.html#custom-ui">Custom UI</a></li>
</ul>
</li>
<li><a href="the_truth/custom_asset/part2.html#what-is-next">What is next?</a></li>
<li><a href="the_truth/custom_asset/part2.html#full-example-source-code">Full example source code</a></li>
</ul>
<h2 id="extending-the-asset-the-truth-type"><a class="header" href="#extending-the-asset-the-truth-type">Extending the asset The Truth Type</a></h2>
<p>The asset type we created is nice but it cannot do much. The Machinery can save anything to file that it can store in the Truth. This thought brings us back to the part: <strong>“What kind of asset do we want to create?”.</strong> </p>
<p>Let us go back to the basic definition of the type <code>my_asset</code>. We defined the type without any properties.</p>
<p>The current implementation looks as follows:</p>
<pre><code class="language-c">// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, 0, 0);
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;my_asset&quot;);
}
</code></pre>
<p>To make this more useful, what we can do is add some properties to the type. We can do this via an array of the type <a href="https://ourmachinery.com//apidoc/foundation/the_truth.h.html#structtm_the_truth_property_definition_t">tm_the_truth_property_definition_t</a>. In this array we can define all the properties we want. </p>
<h2 id="text-file-asset"><a class="header" href="#text-file-asset">Text file asset</a></h2>
<p>Now we are changing the <code>my_asset</code> to be able to store text in it. </p>
<p>First, we need to answer the question: <em>How is a text file defined?</em> </p>
<p>Well, a text file has three properties: </p>
<ol>
<li>It has a file name</li>
<li>A file path</li>
<li>data - A bunch of characters.</li>
</ol>
<p>Consequently, we are defining the <em>import path</em> property to “reimport” our text asset and the data property to store the imported text.</p>
<pre><code class="language-c">    static tm_the_truth_property_definition_t my_asset_properties[] = {
        { &quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING },
        { &quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER},
    };
</code></pre>
<blockquote>
<p><strong>Note:</strong> The type <a href="https://ourmachinery.com//apidoc/foundation/the_truth.h.html#structtm_the_truth_property_definition_t"><em>tm_the_truth_property_definition_t</em></a> has a lot more options. For example, is it possible to hide properties from the editor, etc. For more information, read the documentation <a href="https://ourmachinery.com//apidoc/foundation/the_truth.h.html#structtm_the_truth_property_definition_t"><em>here</em></a><em>.</em></p>
</blockquote>
<p>After we have thought about this, we need to provide the <code>create_object_type</code> function with the new information:</p>
<pre><code class="language-c">static void create_truth_types(struct tm_the_truth_o *tt)
{
    static tm_the_truth_property_definition_t my_asset_properties[] = {
        { &quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING },
        { &quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER},
    };
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, my_asset_properties, 2);
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;my_asset&quot;);
}
</code></pre>
<p>Now we should change the asset name to something more meaningful than <code>my_asset</code>. Lets call it <code>txt</code></p>
<p>The renaming has as a consequence that we need to change three places:</p>
<ul>
<li>Asset Name</li>
<li>Menu Name</li>
<li>File extension</li>
<li>The source file: <code>my_asset.c/h</code> -&gt; <code>txt.c/h</code></li>
</ul>
<p>This will change the code as follows:</p>
<pre><code class="language-c">//.. other code
static void create_truth_types(struct tm_the_truth_o *tt)
{
//... the other code
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;txt&quot;);
}
// .. other code
static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .create = asset_browser_create,
};
</code></pre>
<p>Let's have a look at how it looks in the editor:</p>
<p><img src="https://paper-attachments.dropbox.com/s_892FB4725BEE1D4E7D7CCEA6A89558987964DFF4B0524E03B4E0F6FFCF6E0FED_1609926443262_image.png" alt="creating a new asset" /></p>
<h2 id="load-a-text-file"><a class="header" href="#load-a-text-file">Load a text file</a></h2>
<p>After creating a new asset, the asset looks as following in the editor:</p>
<p><img src="https://paper-attachments.dropbox.com/s_892FB4725BEE1D4E7D7CCEA6A89558987964DFF4B0524E03B4E0F6FFCF6E0FED_1609926772154_image.png" alt="" /></p>
<p>This asset file is still not quite how we want it because we have not loaded a text file yet. Therefore let us load a file next. At first, we will do it by <em>hand</em> via loading a file whenever we are changing the path, and then later on (in the next chapter) we are writing our importer. It will allow us to drag and drop files into the Engine as well or use the <em>Import Menu.</em></p>
<h3 id="custom-ui"><a class="header" href="#custom-ui">Custom UI</a></h3>
<p>To archive our first manual loading, we need to add a custom UI associated with our type. We can do this via the properties aspect <code>TM_TT_ASPECT__PROPERTIES</code>. It means we need to go back to the <code>create_truth_types</code> function and add a new Aspect and a new object associated with this Aspect.</p>
<p>The Aspect expects a <a href="https://ourmachinery.com//apidoc/plugins/editor_views/properties.h.html#structtm_properties_aspect_i"><code>tm_properties_aspect_i</code></a> object. When defining the object, we are focused only on is the custom_ui field. </p>
<blockquote>
<p>Note: This struct has many different fields which are not interesting to us now. (If you want more information on them, check out the <a href="https://ourmachinery.com//apidoc/plugins/editor_views/properties.h.html#structtm_properties_aspect_i">documentation</a>.</p>
</blockquote>
<p>The <code>custom_ui</code> expected s function pointer of the type <code>float (*custom_ui)(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)</code>.</p>
<p>Let us quickly go over this:</p>
<p><em>Function Arguments:</em></p>
<table><thead><tr><th><strong>Argument</strong></th><th><strong>Data Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>1 (<code>args</code>)</td><td><a href="https://ourmachinery.com//apidoc/plugins/editor_views/properties.h.html#structtm_properties_ui_args_t">tm_properties_ui_args_t</a></td><td>A bundled type of important information. For example this is the way you would retrieve your ui instance as well as your uistyle instance. For more information check the <a href="https://ourmachinery.com//apidoc/plugins/editor_views/properties.h.html#structtm_properties_ui_args_t">documentation</a>.</td></tr>
<tr><td>2 (<code>item_rect</code>)</td><td><a href="https://ourmachinery.com//apidoc/foundation/api_types.h.html#structtm_rect_t">tm_rect_t</a></td><td>The ui rectangular of the current item. This can be manipulated in x,y as well as w and h as long as the correct y value is being returned.</td></tr>
<tr><td>3 (<code>object</code>)</td><td><a href="https://ourmachinery.com//apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a></td><td>The truth object id of the current object. Can be used to read information of.</td></tr>
<tr><td>4 (<code>indent</code>)</td><td><code>uint32_t</code></td><td>Used for intention.</td></tr>
</tbody></table>
<p><em>Return values</em></p>
<table><thead><tr><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>float</td><td>This is the being used as the next y value of the following element.</td></tr>
</tbody></table>
<p>We need to define a static instance of the <a href="https://ourmachinery.com//apidoc/plugins/editor_views/properties.h.html#structtm_properties_aspect_i">tm_properties_aspect_i*</a> and a custom UI function.</p>
<pre><code class="language-c">//.. other code
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
// -- code
}
//.. other code    
static tm_properties_aspect_i properties_aspect = {
        .custom_ui = properties__custom_ui,
    };
// .. other code
</code></pre>
<p>Now the properties aspect needs to know about the existence of our custom UI. It follows the same principle as the properties:</p>
<pre><code class="language-c">//.. other code
static void create_truth_types(struct tm_the_truth_o *tt)
{
//... the other code
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__PROPERTIES, &amp;properties_aspect);
}
//... the other code
</code></pre>
<p>In the editor, the change is imminently visible. The UI is gone because we have chosen to provide our custom UI.</p>
<p><img src="https://paper-attachments.dropbox.com/s_892FB4725BEE1D4E7D7CCEA6A89558987964DFF4B0524E03B4E0F6FFCF6E0FED_1609928409366_image.png" alt="" /></p>
<p>It is time to add the imported file property back to the UI panel. The first step is to think about what our property shall represent:
When we defined it, we described it as type <code>TM_THE_TRUTH_PROPERTY_TYPE_STRING</code>. 
It is essential to know because the <a href="https://ourmachinery.com//apidoc/plugins/editor_views/properties.h.html#properties.h">properties header file</a> has the <a href="https://ourmachinery.com//apidoc/plugins/editor_views/properties.h.html#structtm_properties_view_api">properties view API</a>, which has many built-in functions for default behavior.</p>
<p>One of the things we can find in there is the <a href="https://ourmachinery.com//apidoc/plugins/editor_views/properties.h.html#structtm_properties_view_api.ui_open_path()">ui_open_path</a> which sounds perfect for the import path. The buffer (data) does not need to be displayed yet. Before using any Properties-View API functions, we need to request the API in our load plugin function.</p>
<pre><code class="language-c">// -- api's
static struct tm_properties_view_api *tm_properties_view_api;
//.. other code 
// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
//.. other code 
    tm_properties_view_api = reg-&gt;get(TM_PROPERTIES_VIEW_API_NAME);
//.. other code 
} 
</code></pre>
<p>Now we can use and implement the path opening function. Let us look at its <a href="https://ourmachinery.com//apidoc/plugins/editor_views/properties.h.html#structtm_properties_view_api.ui_open_path()">signature</a> first:</p>
<p><code>float (*ui_open_path)(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, const char *name, const char *tooltip, tm_tt_id_t object, uint32_t property, const char *extensions, const char *description, bool *picked)</code></p>
<p><em>Function Arguments:</em></p>
<table><thead><tr><th><strong>Argument</strong></th><th><strong>Data Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>1 (<code>args</code>)</td><td><a href="https://ourmachinery.com//apidoc/plugins/editor_views/properties.h.html#structtm_properties_ui_args_t">tm_properties_ui_args_t</a></td><td>A bundled type of important information. For example this is the way you would retrieve your UI instance as well as your <code>uistyle</code> instance. For more information check the <a href="https://ourmachinery.com//apidoc/plugins/editor_views/properties.h.html#structtm_properties_ui_args_t">documentation</a>.</td></tr>
<tr><td>2 (<code>item_rect</code>)</td><td><a href="https://ourmachinery.com//apidoc/foundation/api_types.h.html#structtm_rect_t">tm_rect_t</a></td><td>The UI rectangular of the current item. This can be manipulated in x,y as well as w and h as long as the correct y value is being returned.</td></tr>
<tr><td>3 (<code>n</code>ame)</td><td><code>const char*</code></td><td>This is the name the Properties tab will display as the title in front of the text field.</td></tr>
<tr><td>4 (<code>t</code>ooltip)</td><td><code>const char*</code></td><td>Extra information if needed. (Optional)</td></tr>
<tr><td>5 (object)</td><td><a href="https://ourmachinery.com//apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a></td><td>The truth object id of the current object. Can be used to read information of.</td></tr>
<tr><td>6 (property)</td><td><code>uint32_t</code></td><td>Property index</td></tr>
<tr><td>7 (<code>extensions</code>)</td><td><code>const char*</code></td><td>List of potential file extension supported by the open dialog</td></tr>
<tr><td>8 (<code>description</code>)</td><td><code>const char*</code></td><td>List of descriptions for the potential file extensions</td></tr>
<tr><td>9 (picked)</td><td><code>bool*</code></td><td>Out pointer indicating if a file has been picked or not. (optional)</td></tr>
</tbody></table>
<p><em>Return values</em></p>
<table><thead><tr><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>float</td><td>This is the being used as the next y value of the following element.</td></tr>
</tbody></table>
<p>To implement the function all that's needed to remember is what index the property had.</p>
<pre><code class="language-c">    static tm_the_truth_property_definition_t my_asset_properties[] = {
        { &quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING },
        { &quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER},
    };
</code></pre>
<p>The index is 0 there for we are no ready to implement the function:</p>
<pre><code class="language-c">//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    // -- code
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, &quot;Imported Path&quot;, &quot;Path that the text file was imported from.&quot;, object, 0, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        // import...
    }
    return item_rect.y;
}
</code></pre>
<p>Remembering all of those indices is quite cucumbersome! Therefore, it is better to define an enum in our header file. Define an <code>enum</code> for each property <code>TM_TT_PROP__[NAME_OF_TYPE]__[NAME_OF_PROPERTY]</code></p>
<pre><code class="language-c">#pragma once
#include &lt;foundation/api_types.h&gt;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0x1e12ba1f91b99960ULL)

enum {
    TM_TT_PROP__MY_ASSET__FILE,
    TM_TT_PROP__MY_ASSET__DATA,
}
</code></pre>
<p>(<code>txt.h</code>)</p>
<p>When we compiled this we can test it in the engine, just by adding a new text file click on the Import Path:</p>
<p><img src="https://paper-attachments.dropbox.com/s_892FB4725BEE1D4E7D7CCEA6A89558987964DFF4B0524E03B4E0F6FFCF6E0FED_1609931496164_image.png" alt="" /></p>
<p>The next step is using the OS API to load a file from the disc and store it in the buffer. This process works after the same principle as adding the properties view API. </p>
<p>The OS API (<a href="https://ourmachinery.com//apidoc/foundation/os.h.html#structtm_os_api">tm_os_api</a>) lives in the <code>os.h</code> and has a member called <a href="https://ourmachinery.com//apidoc/foundation/os.h.html#structtm_os_file_io_api">file_io</a>, allowing access to the <code>tm_os_file_io_api</code>. With this API, we can read a file. The following example code shows how reading the file and storing it in a buffer could look like in this case. </p>
<pre><code class="language-c">//other includes
#include &lt;foundation/os.h&gt;
#include &lt;foundation/buffer.h&gt;
//.. other code
//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);

        tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(file);

        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);

        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(file);
        tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);

        const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
        tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, object);
        tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id); // 1 = data property index.
        tm_the_truth_api-&gt;commit(tt, asset_obj, TM_TT_NO_UNDO_SCOPE);
    }
    return item_rect.y;
}
</code></pre>
<p>First, we need to read out the file path from our The Truth object. After that, we can create the buffer we want to add to our <em>data</em> property (index 1 or <code>TM_TT_PROP___MY_ASSET__DATA</code>). 
The buffers live in the <code>buffer.h</code>. We create the buffer via The Truth, and it also owns the memory. We are using the <a href="https://ourmachinery.com//apidoc/foundation/os.h.html#structtm_os_file_system_api">file_system API</a> to get the size of the text file. We need to know how big the file is to understand how big the buffer should be. </p>
<blockquote>
<p>Note: We should also check if the file exists. It has been left out because we just picked the file. </p>
</blockquote>
<p>Then we are reading the file from the disc and store its content in the allocated buffer. The next step is to add the buffer to the Truth buffers via the <a href="https://ourmachinery.com//apidoc/foundation/buffer.h.html#structtm_buffers_i.add()">buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);</a> call. It adds a buffer containing the specified data of size. It returns an ID identifying the new buffer. For more information, read <a href="https://ourmachinery.com//apidoc/foundation/buffer.h.html#structtm_buffers_i.add()">here</a>.</p>
<p>Now we need to ask the Truth to give us a writeable object. Objects from the Truth are immutable in their default state and can only be made mutable by asking explicitly for a writable object.
This happens via the <a href="https://ourmachinery.com//apidoc/foundation/the_truth.h.html#structtm_the_truth_api.write()">tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, object);</a> call.</p>
<p>With the writeable object, we can set the buffer, and then we can commit the changes to the Truth itself.</p>
<p>This iteration is the first, but the issue with it is that we cannot import or drag and drop a .txt file into the Engine. We will tackle this issue in the <a href="the_truth/custom_asset/part2.html#">next part</a>.</p>
<h2 id="what-is-next-1"><a class="header" href="#what-is-next-1">What is next?</a></h2>
<p>The next part will refactor the current code and show you how to make your code and asset more useful by showing you how to program an importer.</p>
<p><a href="the_truth/custom_asset/part2.html#">Part 3</a></p>
<h2 id="full-example-source-code"><a class="header" href="#full-example-source-code">Full example source code</a></h2>
<p><code>txt.h</code></p>
<pre><code class="language-c">#pragma once
#include &lt;foundation/api_types.h&gt;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0x1e12ba1f91b99960ULL)

enum {
    TM_TT_PROP__MY_ASSET__FILE,
    TM_TT_PROP__MY_ASSET__DATA,
};
</code></pre>
<p><code>txt.c</code></p>
<pre><code class="language-c">// -- api's
static struct tm_the_truth_api *tm_the_truth_api;
static struct tm_properties_view_api *tm_properties_view_api;
static struct tm_os_api *tm_os_api;
// -- inlcudes
#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/the_truth.h&gt;
#include &lt;foundation/undo.h&gt;
#include &lt;foundation/the_truth_assets.h&gt;
#include &lt;foundation/localizer.h&gt;
#include &lt;foundation/macros.h&gt;
#include &lt;foundation/os.h&gt;
#include &lt;foundation/buffer.h&gt;

#include &lt;plugins/editor_views/asset_browser.h&gt;
#include &lt;plugins/editor_views/properties.h&gt;

#include &quot;txt.h&quot;

//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);
        tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(file);
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(file);
        tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
        tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, object);
        tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
        tm_the_truth_api-&gt;commit(tt, asset_obj, TM_TT_NO_UNDO_SCOPE);
    }
    return item_rect.y;
}
// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    static tm_the_truth_property_definition_t my_asset_properties[] = {
        {&quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING},
        {&quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER},
    };
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, my_asset_properties, TM_ARRAY_COUNT(my_asset_properties));
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;txt&quot;);
    static tm_properties_aspect_i properties_aspect = {
        .custom_ui = properties__custom_ui,
    };
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__PROPERTIES, &amp;properties_aspect);
}
// -- asset browser regsiter interface
static tm_tt_id_t asset_browser_create(struct tm_asset_browser_create_asset_o *inst, tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
    return tm_the_truth_api-&gt;create_object_of_type(tt, type, undo_scope);
}
static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .create = asset_browser_create,
};
// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_the_truth_api = reg-&gt;get(TM_THE_TRUTH_API_NAME);
    tm_properties_view_api = reg-&gt;get(TM_PROPERTIES_VIEW_API_NAME);
    tm_os_api = reg-&gt;get(TM_OS_API_NAME);
    tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
    tm_add_or_remove_implementation(reg, load, TM_ASSET_BROWSER_CREATE_ASSET_INTERFACE_NAME, &amp;asset_browser_create_my_asset);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-custom-asset-part-3"><a class="header" href="#create-a-custom-asset-part-3">Create a custom asset part 3</a></h1>
<p>This walkthrough shows you how to add a custom asset to the Engine. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="the_truth/custom_asset//the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. The goal for this walkthrough is to write a text file asset.</p>
<p>This part will cover the following topics:</p>
<ul>
<li>How to write an importer</li>
</ul>
<blockquote>
<p>You can find the whole source code in its git repo: <a href="https://github.com/simon-ourmachinery/example-text-file-asset">example-text-file-asset</a></p>
</blockquote>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_truth/custom_asset/part3.html#custom-importer-for-text-files">Custom importer for text files</a></li>
<li><a href="the_truth/custom_asset/part3.html#import-task-set-up">Import Task set up</a></li>
<li><a href="the_truth/custom_asset/part3.html#import-task-implementation">Import task implementation</a></li>
<li><a href="the_truth/custom_asset/part3.html#enabling-reimport">Enabling reimport</a></li>
<li><a href="the_truth/custom_asset/part3.html#refactor-the-custom-ui-import-functionality">Refactor the Custom UI import functionality</a></li>
<li><a href="the_truth/custom_asset/part3.html#the-end">The end</a></li>
</ul>
<h2 id="custom-importer-for-text-files"><a class="header" href="#custom-importer-for-text-files">Custom importer for text files</a></h2>
<p>In this part, we are adding the ability to import a text file into the Engine. To implement an importer, we need the following APIs:</p>
<table><thead><tr><th><strong>Name</strong></th><th><strong>header file</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>tm_asset_io_api</td><td>foundation/asset_io.h</td><td>This api provides us with the interface for the actual importer.</td></tr>
<tr><td>tm_temp_allocator_api</td><td>foundation/temp_allocator.h</td><td>Provides a easy way to allocate temporary memory.</td></tr>
<tr><td>tm_allocator_api</td><td>foundation/allocator.h</td><td>Allows us access to different kind of allocators. For example to the system allocator. We need this one later when we rewrite our reimport.</td></tr>
<tr><td>tm_path_api</td><td>foundation/path.h</td><td>Allows us to split a path.</td></tr>
<tr><td>tm_api_registry_api</td><td>foundation/api_registry.h</td><td>Allows us to retrive a API from the registry.</td></tr>
<tr><td>tm_task_system_api</td><td>foundation/task_system.h</td><td>Allowes us to spawm tasks</td></tr>
</tbody></table>
<p>After we have included all the needed header files and retrieved all the APIs from the registry, we can start to write an importer.</p>
<blockquote>
<p>Note: <code>tm_api_registry_api</code> can be retrived from the reg parameter in the <code>tm_load_plugin</code> function. <code>tm_global_api_registry = reg;</code></p>
</blockquote>
<p>The Machinery has a generic interface for asset importers. It requires a bunch of functions to be able to work as intended. The struct we need to implement is called <a href="https://ourmachinery.com//apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_i</a>. It requires us to set the following members:</p>
<table><thead><tr><th>Member</th><th>Description</th></tr></thead><tbody>
<tr><td>enabled</td><td>A function ptr that returns a bool. If the return value is true the importer is active.</td></tr>
<tr><td>can_import</td><td>A function ptr that returns <code>true</code> if this asset IO interface can import archives with the file extension <code>extension</code>. This can be achieved by comparing the file extesions.<br><br>Optional, if not implemented, nothing can be imported.</td></tr>
<tr><td>can_reimport</td><td>A function ptr that returns <code>true</code> if this asset IO interface can re-import the specified truth asset (of type <code>TM_TT_TYPE_ASSET</code>). Optional, if not implemented, nothing can be re-importe</td></tr>
<tr><td>importer_extensions_string</td><td>A function ptr that shall append the correct file extention string to the list of possible file extenstions</td></tr>
<tr><td>importer_description_string</td><td>A function ptr that shall append the correct file extention descriptions string to the list of possible file extenstions descriptions.</td></tr>
<tr><td>import_asset</td><td>The actual function that starts a import task. If non-zero, the return value is the ID of the background task from <code>tm_task_system_api</code> that does the import.</td></tr>
</tbody></table>
<p>All these members expect a function pointer. Therefore, we need to provide the functionality.</p>
<p>To implement the first functions, we need to do the following steps:</p>
<pre><code class="language-c">//... other includes
#include &lt;foundation/carray_print.inl&gt;
#include &lt;foundation/string.inl&gt;
#include &lt;foundation/localizer.h&gt;
//... other code
static bool asset_io__enabled(struct tm_asset_io_o *inst)
{
    return true;
}
static bool asset_io__can_import(struct tm_asset_io_o *inst, const char *extension)
{
    return tm_strcmp_ignore_case(extension, &quot;txt&quot;) == 0;
}
static bool asset_io__can_reimport(struct tm_asset_io_o *inst, struct tm_the_truth_o *tt, tm_tt_id_t asset)
{
    const tm_tt_id_t object = tm_the_truth_api-&gt;get_subobject(tt, tm_tt_read(tt, asset), TM_TT_PROP__ASSET__OBJECT);
    return tm_tt_type(object).u64 == tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET).u64;
}
static void asset_io__importer_extensions_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;txt&quot;);
}
static void asset_io__importer_description_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;.txt&quot;);
}
</code></pre>
<p>Let us go through them:</p>
<ul>
<li>The <code>enabled</code> function returns true because we want the importer to work. </li>
<li>The <code>asset_io__can_import</code> will compare the given extension with the one we want to support.</li>
</ul>
<blockquote>
<p>Note: <code>tm_strcmp_ignore_case</code> requires a localizer. That is why we need the localizer API and the localizer header file. It is not needed if the importer shall be case-sensitive.</p>
</blockquote>
<ul>
<li>The <code>asset_io__can_reimport</code> compares the object type of the given object with the object of our type. </li>
</ul>
<blockquote>
<p><code>TM_TT_PROP__ASSET__OBJECT</code> is the property of the <a href="https://ourmachinery.com//apidoc/foundation/the_truth_assets.h.html#tm_tt_type__asset">TM_TT_TYPE__ASSET</a> type which holds the object associated with the asset.</p>
</blockquote>
<p>The last two functions will append the file extension <code>.txt</code> to the file extensions and description. Note that the argument output is a <a href="https://ourmachinery.com//apidoc/foundation/carray.inl.html#carray.inl">carray</a>. That is why we can use the <code>tm_carray_temp_printf</code> function.</p>
<blockquote>
<p>Note: The <code>carray_print.h</code> requires the <code>tm_sprintf_api</code>. Therefore, we need to include the right header here.</p>
</blockquote>
<h2 id="import-task-set-up"><a class="header" href="#import-task-set-up">Import Task set up</a></h2>
<p>The importer function <code>asset_io__import_asset</code> can spawn a task with the task system and pass through the needed information. We need to create a data structure to hold all our data.</p>
<p><em>What data does our task need?</em> 
This task needs to know where to find the file. Moreover it needs to access some essential types such as the Truth and allocator. The struct could look like this:</p>
<pre><code class="language-c">struct task__import_txt
{
    uint64_t bytes;
    struct tm_asset_io_import args;
    char file[8];
};
</code></pre>
<p>The <code>asset_io</code> header has a nice utility struct predefined the <a href="https://ourmachinery.com//apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_import</a>. When an asset is being imported the caller of the  <code>asset_io__import_asset()</code> will hand through all the needed details: </p>
<ul>
<li>The right Truth object</li>
<li>the correct allocator. </li>
</ul>
<p>The function itself looks like this:</p>
<pre><code class="language-c">// .. other code
static uint64_t asset_io__import_asset(struct tm_asset_io_o *inst, const char *file, const struct tm_asset_io_import *args)
{
    const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
    struct task__import_txt *task = tm_alloc(args-&gt;allocator, bytes);
    *task = (struct task__import_txt){
        .bytes = bytes,
        .args = *args,
    };
    strcpy(task-&gt;file, file);
    return task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
}
</code></pre>
<blockquote>
<p><strong>Important</strong>: The task is the memory owner and needs to clean it up at the end of the execution!</p>
</blockquote>
<p>This line <code>task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);</code> will run a task and return its id. The actual task is the function <code>task__import_txt()</code>. </p>
<blockquote>
<p>Info: For more information on the task system check the <a href="https://ourmachinery.com//apidoc/foundation/task_system.h.html#structtm_task_system_api.run_task()">documentation</a>.</p>
</blockquote>
<h2 id="import-task-implementation"><a class="header" href="#import-task-implementation">Import task implementation</a></h2>
<p>The import task has the function to import data and clean up afterward.</p>
<p>It may look like this:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
// all our work
}
</code></pre>
<p>The data <code>ptr</code> needs to be cast into our defined data type: <code>task__import_txt</code>. You could use the task id to update its progress. We do not need to do it in this example.</p>
<blockquote>
<p>For more information on how to update the status of a task. It will be shown in the editor check out the <a href="https://ourmachinery.com//apidoc/foundation/progress_report.h.html#structtm_progress_report_api">documentation</a>.</p>
</blockquote>
<p>We are left with the following steps:</p>
<ul>
<li>Implement the actual importing (similar to the previous chapter).</li>
<li>Implement the reimport.</li>
</ul>
<p>First, we need to retrieve the basic information from the task data:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
//.. more
}
</code></pre>
<p>After that, we implement the same code as in the previous chapter. We need to open the file, allocate a buffer and add the buffer to the object, either a new one (import) or an existing one (reimport).</p>
<p><strong>An important note is to do this time error checking</strong>: </p>
<ul>
<li>Does the file exist? </li>
<li>Does the file size match with the read file? </li>
</ul>
<p>To ask those questions is vital because we are in the async territory. In case of an error, we want to inform the user. Therefore, we need to get the logging API (<code>tm_logger_api = reg-&gt;get(TM_LOGGER_API_NAME);</code>) as well. You can find it in the <code>foundation/log.h</code> file.</p>
<p>The subsequent step is to check if the file exists. You can do this through the filesystem API:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
    // .. code
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<p>Now we combine all the knowledge from this chapter and the previous chapter. We need to create a new asset via code for the import, and for the reimport, we need to update an existing file. 
Before we do all of this, let us first read the file and create the buffer.</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
// ..code
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<p>After this, we should ensure that the file size matches the size of the read data.</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
        {
        // ..code
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<p>With this out of the way, we can use our knowledge from the [last part](#): </p>
<ul>
<li>How to add an asset via code.</li>
</ul>
<p>The first step was to create the new object and add the data to it.</p>
<pre><code class="language-c">const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
 tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
</code></pre>
<p>After that, we are using the <code>tm_asset_browser_add_asset_api</code> to add the asset to the asset browser. </p>
<pre><code class="language-c">tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
</code></pre>
<p>We are getting the API first, because we do not need it anywhere else than in this case. Then we need to extract the file name of the imported file. You can do this with the <em>path API</em>'s <code> tm_path_api-&gt;base()</code> function. Be aware this function requires a <code>tm_str_t</code> which you an create from a normal c string (<code>const char*</code>) via <code>tm_str()</code>. To access the underlaying c string again just call <code>.data</code> on the <code>tm_str_t</code>.</p>
<blockquote>
<p>Used to represent a string slice with pointer and length.</p>
<p>This lets you reason about parts of a string, which you are not able to do with standard NULL-terminated strings.</p>
<p><a href="https://ourmachinery.com//apidoc/foundation/api_types.h.html#structtm_str_t">documentation</a></p>
</blockquote>
<p>After this step we need to get the current folder. Therefore we are asking the <code>tm_asset_browser_add_asset_api</code> what the current folder is. Then we decide if want to select the file. At the end we are calling add function of the <code>tm_asset_browser_add_asset_api-&gt;add()</code>. </p>
<blockquote>
<p><strong>Note:</strong> We do not have any asset labels for our current asset therefore we do not pass them to the add function, otherwise the last 2 arguments would be different than <code>0</code> and <code>0</code>.</p>
</blockquote>
<pre><code class="language-c">                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                // we do not have any asset label therefore we do not need to pass them thats why the last
                // 2 arguments are 0 and 0!
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui,0,0);
</code></pre>
<p>That's it for the import.  Before we move on, we need to clean up! No Allocation without deallocation!</p>
<pre><code class="language-c">    tm_free(args-&gt;allocator, task, task-&gt;bytes);
</code></pre>
<blockquote>
<p>Info:  If you don't do this, the Engine will inform you that there is a memory leak in the logs/terminal.</p>
</blockquote>
<p>Now bringing it all together:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
        {
const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
 tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                // we do not have any asset label therefore we do not need to pass them thats why the last
                // 2 arguments are 0 and 0!
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui,0,0);
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
    tm_free(args-&gt;allocator, task, task-&gt;bytes);
}
</code></pre>
<h2 id="enabling-reimport"><a class="header" href="#enabling-reimport">Enabling reimport</a></h2>
<p>The previous import task would never be able to reimport an asset. Let us fix this quickly!
The <code>tm_asset_io_import</code> has a field called <code>reimport_into</code> of type <code>tm_tt_id_t</code>, which we did not set. If the current context is an import, otherwise a valid the truth id. It enables us to check if the current context is an import or reimport. To achieve this, we need to update the <code>reimport_into</code> object with the newly created object asset_obj, and you can do this via The Truth API function <code>retarget_write.</code> It takes an object and updates it with the new content. Commit the change and destroy the temporary object (asset_obj).</p>
<pre><code class="language-c">            if (args-&gt;reimport_into.u64)
            {
                tm_the_truth_api-&gt;retarget_write(tt, asset_obj, args-&gt;reimport_into);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;destroy_object(tt, asset_id, args-&gt;undo_scope);
            }
</code></pre>
<p>This changes the source code as following:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
        {
            const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
            const uint64_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
            const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
            tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
            tm_the_truth_api-&gt;set_buffer(tt, asset_obj, 1, buffer_id);
            tm_the_truth_api-&gt;set_string(tt, asset_obj, 0, txt_file);
            if (args-&gt;reimport_into.u64)
            {
                tm_the_truth_api-&gt;retarget_write(tt, asset_obj, args-&gt;reimport_into);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;destroy_object(tt, asset_id, args-&gt;undo_scope);
            }
            else
            {
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                TM_INIT_TEMP_ALLOCATOR(ta);
                const char *ext;
                const char *name = tm_path_api-&gt;split(txt_file, &amp;ext);
                const char *asset_name = tm_temp_allocator_api-&gt;printf(ta, &quot;%.*s&quot;, ext - name, name);
                tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                // we do not have any asset label therefore we do not need to pass them thats why the last
                // 2 arguments are 0 and 0!
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui,0,0);
                TM_SHUTDOWN_TEMP_ALLOCATOR(ta);
            }
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
    tm_free(args-&gt;allocator, task, task-&gt;bytes);
}
</code></pre>
<h2 id="refactor-the-custom-ui-import-functionality"><a class="header" href="#refactor-the-custom-ui-import-functionality">Refactor the Custom UI import functionality</a></h2>
<p>The last step before this part is over is to refactor the initial import of the file when we change the property in its custom UI. The current code does everything async. Besides, if we would leave this, we would have code duplication, which we want to avoid, for better-maintained reasons.</p>
<p>You might argue that it is the same process as just reimporting an asset when we change the path. That's correct!</p>
<p>We can reuse our Import-Task. Before we can launch a task, we need to ensure we have the right setup!
We can check the documentation of <a href="https://ourmachinery.com//apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_import</a> to ensure we do not forget anything important. </p>
<p>After we have done that, we will find that the reimport task needs besides the file name:</p>
<ul>
<li>the allocator</li>
<li>the current Truth</li>
<li>the object to import reimport into</li>
</ul>
<p>Now we can write our reimport task code. The code itself looks like this:</p>
<pre><code class="language-c">            tm_allocator_i *allocator = tm_allocator_api-&gt;system;
            const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
            struct task__import_txt *task = tm_alloc(allocator, bytes);
            *task = (struct task__import_txt){
                .bytes = bytes,
                .args = {
                    .allocator = allocator,
                    .tt = tt,
                    .reimport_into = object}};
            strcpy(task-&gt;file, file);
            task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
</code></pre>
<p>First, we ask for the system allocator (This one has the same lifetime as the program is running). Then, we allocate our task, including bytes for the string. Remember the struct structure:</p>
<pre><code class="language-c">// -- struct definitions
struct task__import_txt
{
    uint64_t bytes;
    struct tm_asset_io_import args;
    char file[8];
};
// .. other code
</code></pre>
<p>After that, we initialize our struct and its members with the needed data. Moreover, we copy the chars of the file name into our struct + extra bytes, and then we ask the task system to run the task.</p>
<p>This, combined with the custom UI functions, should look similar to this:</p>
<pre><code class="language-c">//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);
        {
            tm_allocator_i *allocator = tm_allocator_api-&gt;system;
            const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
            struct task__import_txt *task = tm_alloc(allocator, bytes);
            *task = (struct task__import_txt){
                .bytes = bytes,
                .args = {
                    .allocator = allocator,
                    .tt = tt,
                    .reimport_into = object}};
            strcpy(task-&gt;file, file);
            task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
        }
    }
    return item_rect.y;
}
</code></pre>
<p><em>(For more information on the structure of these functions, please check the previous part)</em></p>
<ul>
<li><a href="the_truth/custom_asset/part3.html#">Part 1</a></li>
<li><a href="the_truth/custom_asset/part3.html#">Part 2</a></li>
</ul>
<h2 id="the-end"><a class="header" href="#the-end">The end</a></h2>
<p>It is the end of this walkthrough. You might have gained a better understanding:</p>
<ul>
<li>Of the Truth </li>
<li>How to create an asset</li>
<li>How to import assets into the Engine</li>
<li>How to provide a custom UI. </li>
</ul>
<p>If you wanted to see a more complex example of an importer, you could check the assimp importer example <code>samples\plugins\assimp</code>.</p>
<p>All the source code is available on GitHub in the <a href="https://github.com/simon-ourmachinery/example-text-file-asset"><strong>example-text-file-asset</strong></a> repo.</p>
<p><strong>Full Source Code</strong></p>
<p><code>txt.h</code></p>
<pre><code class="language-c">#pragma once
#include &lt;foundation/api_types.h&gt;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0x1e12ba1f91b99960ULL)

enum {
    TM_TT_PROP__MY_ASSET__FILE,
    TM_TT_PROP__MY_ASSET__DATA,
};
</code></pre>
<p><code>txt.c</code></p>
<pre><code class="language-c">// -- api's
static struct tm_api_registry_api *tm_global_api_registry;
static struct tm_the_truth_api *tm_the_truth_api;
static struct tm_properties_view_api *tm_properties_view_api;
static struct tm_os_api *tm_os_api;
static struct tm_path_api *tm_path_api;
static struct tm_temp_allocator_api *tm_temp_allocator_api;
static struct tm_logger_api *tm_logger_api;
static struct tm_localizer_api *tm_localizer_api;
static struct tm_asset_io_api *tm_asset_io_api;
static struct tm_task_system_api *task_system;
static struct tm_allocator_api *tm_allocator_api;
static struct tm_sprintf_api *tm_sprintf_api;

// -- inlcudes

#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/asset_io.h&gt;
#include &lt;foundation/buffer.h&gt;
#include &lt;foundation/carray_print.inl&gt;
#include &lt;foundation/localizer.h&gt;
#include &lt;foundation/log.h&gt;
#include &lt;foundation/macros.h&gt;
#include &lt;foundation/os.h&gt;
#include &lt;foundation/path.h&gt;
#include &lt;foundation/sprintf.h&gt;
#include &lt;foundation/string.inl&gt;
#include &lt;foundation/task_system.h&gt;
#include &lt;foundation/temp_allocator.h&gt;
#include &lt;foundation/the_truth.h&gt;
#include &lt;foundation/the_truth_assets.h&gt;
#include &lt;foundation/undo.h&gt;

#include &lt;plugins/editor_views/asset_browser.h&gt;
#include &lt;plugins/editor_views/properties.h&gt;

#include &quot;txt.h&quot;
// -- struct definitions
struct task__import_txt
{
    uint64_t bytes;
    struct tm_asset_io_import args;
    char file[8];
};
/////
// -- functions:
////
// --- importer
static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists) {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size) {
            const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
            const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
            const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
            tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
            tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
            tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
            if (args-&gt;reimport_into.u64) {
                tm_the_truth_api-&gt;retarget_write(tt, asset_obj, args-&gt;reimport_into);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;destroy_object(tt, asset_id, args-&gt;undo_scope);
            } else {
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                struct tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui, 0, 0);
            }
        } else {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    } else {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
    tm_free(args-&gt;allocator, task, task-&gt;bytes);
}

static bool asset_io__enabled(struct tm_asset_io_o *inst)
{
    return true;
}
static bool asset_io__can_import(struct tm_asset_io_o *inst, const char *extension)
{
    return tm_strcmp_ignore_case(extension, &quot;txt&quot;) == 0;
}
static bool asset_io__can_reimport(struct tm_asset_io_o *inst, struct tm_the_truth_o *tt, tm_tt_id_t asset)
{
    const tm_tt_id_t object = tm_the_truth_api-&gt;get_subobject(tt, tm_tt_read(tt, asset), TM_TT_PROP__ASSET__OBJECT);
    return object.type == tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET).u64;
}
static void asset_io__importer_extensions_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;txt&quot;);
}
static void asset_io__importer_description_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;.txt&quot;);
}
static uint64_t asset_io__import_asset(struct tm_asset_io_o *inst, const char *file, const struct tm_asset_io_import *args)
{
    const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
    struct task__import_txt *task = tm_alloc(args-&gt;allocator, bytes);
    *task = (struct task__import_txt){
        .bytes = bytes,
        .args = *args,
    };
    strcpy(task-&gt;file, file);
    return task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
}
static struct tm_asset_io_i txt_asset_io = {
    .enabled = asset_io__enabled,
    .can_import = asset_io__can_import,
    .can_reimport = asset_io__can_reimport,
    .importer_extensions_string = asset_io__importer_extensions_string,
    .importer_description_string = asset_io__importer_description_string,
    .import_asset = asset_io__import_asset
};

// -- asset on its own

//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked) {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);
        {
            tm_allocator_i *allocator = tm_allocator_api-&gt;system;
            const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
            struct task__import_txt *task = tm_alloc(allocator, bytes);
            *task = (struct task__import_txt){
                .bytes = bytes,
                .args = {
                    .allocator = allocator,
                    .tt = tt,
                    .reimport_into = object }
            };
            strcpy(task-&gt;file, file);
            task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
        }
    }
    return item_rect.y;
}

// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    static tm_the_truth_property_definition_t my_asset_properties[] = {
        { &quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING },
        { &quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER },
    };
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, my_asset_properties, TM_ARRAY_COUNT(my_asset_properties));
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;txt&quot;);
    static tm_properties_aspect_i properties_aspect = {
        .custom_ui = properties__custom_ui,
    };
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__PROPERTIES, &amp;properties_aspect);
}

// -- asset browser regsiter interface
static tm_tt_id_t asset_browser_create(struct tm_asset_browser_create_asset_o *inst, tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
    return tm_the_truth_api-&gt;create_object_of_type(tt, type, undo_scope);
}
static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .create = asset_browser_create,
};

// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_the_truth_api = reg-&gt;get(TM_THE_TRUTH_API_NAME);
    tm_properties_view_api = reg-&gt;get(TM_PROPERTIES_VIEW_API_NAME);
    tm_os_api = reg-&gt;get(TM_OS_API_NAME);
    tm_path_api = reg-&gt;get(TM_PATH_API_NAME);
    tm_temp_allocator_api = reg-&gt;get(TM_TEMP_ALLOCATOR_API_NAME);
    tm_allocator_api = reg-&gt;get(TM_ALLOCATOR_API_NAME);
    tm_logger_api = reg-&gt;get(TM_LOGGER_API_NAME);
    tm_localizer_api = reg-&gt;get(TM_LOCALIZER_API_NAME);
    tm_asset_io_api = reg-&gt;get(TM_ASSET_IO_API_NAME);
    task_system = reg-&gt;get(TM_TASK_SYSTEM_API_NAME);
    tm_sprintf_api = reg-&gt;get(TM_SPRINTF_API_NAME);
    tm_global_api_registry = reg;
    if (load)
        tm_asset_io_api-&gt;add_asset_io(&amp;txt_asset_io);
    else
        tm_asset_io_api-&gt;remove_asset_io(&amp;txt_asset_io);
    tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
    tm_add_or_remove_implementation(reg, load, TM_ASSET_BROWSER_CREATE_ASSET_INTERFACE_NAME, &amp;asset_browser_create_my_asset);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui"><a class="header" href="#ui">UI</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
